

In Julia, we have a finite state machine defined as the following:

struct FSMGeno{T} <: Genotype
    start::T
    ones::Set{T}
    zeros::Set{T}
    links::Dict{Tuple{T, Bool}, T}
end

We can understand this as a directed graph with labeled edges and nodes, where the set of 
possible node labels is ["0", "0_start", "1", "1_start"], and the set of possible edge labels is
["0", "1", "01"]. Translate the following FSMGeno into a graph:

g = FSMGeno(
    1, 
    Set([3]), 
    Set([1, 2]), 
    Dict{Tuple{Int, Bool}, Int}(
        (1, 0) => 2, 
        (1, 1) => 1, 
        (2, 0) => 3, 
        (2, 1) => 3, 
        (3, 0) => 3, 
        (3, 1) => 2)
)


Implement the following psuedocode. If you understand, give an english description beforehand.
Algorithm 1: CreatePrimeGraph
Input: DiGraph (as FSMGeno)
Output: PGraph (as FSMGeno)
procedure MakePGraph
    dirEdges ← DiGraph.edges ▷ Initialize edge list
    dirNodes ← DiGraph.nodes ▷ Initialize node list
    PGraph ← Empty Graph ▷ Initialize an empty prime graph
    for n in dirNodes do:
        nonPrimeNode ← n.id ▷ store the id of node n
        primeNode ← n.id + ’p’ ▷ create an id for the n’s prime node
        PGraph ← AddNode(primeNode) ▷ add prime node
        PGraph ← AddNode(nonPrimeNode) ▷ add non-prime node
        PGraph ← AddEdge(primeNode, nonPrimeNode) ▷ add an edge between prime and non-prime node pairs
    for e in dirEdges do:
        source ← e.initial.id ▷ store edge head id
        primeNodeTarget ← e.terminal.id + ’p’ ▷ store the tail node’s prime id
        PGraph ← AddEdge(source, primeNodeTarget) ▷ add edge to PGraph using ids
        return PGraph