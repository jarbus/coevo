export Spawner, Species
export ScoreOutcome, IdentitySelector, Replacer
export EvoState

@Base.kwdef struct Spawner{
    I <: IndivConfig, P <: PhenoConfig, RP <: Replacer, S <: Selector,
    RC <: Recombiner, M <: Mutator, A <: Archiver
}
    spid::Symbol
    npop::Int
    icfg::I
    phenocfg::P 
    replacer::RP
    selector::S
    recombiner::RC
    mutators::Vector{M}
    archiver::A
    spargs::Vector{Any} = Any[]
end

# The initial population for each species is generated by the spawner's IndivConfig
# A Species is created and tagged it the spawner's PhenoCfg and returned
function(s::Spawner)(rng::AbstractRNG, sc::SpawnCounter)
    pop = s.icfg(rng, sc, s.npop, s.spargs...)
    Species(s.spid, s.phenocfg, pop)
end

# The initial population for each species is generated taking the RNG object and 
# SpawnCounter from the EvoState of the CoevConfig
function(s::Spawner)(evostate::EvoState)
    s(evostate.rng, evostate.counters[s.spid])
end

# This fulfills the core reproduction phase of the evolutionary algorithm
# Given an input of a Species of veterans, the spawner will generate a new Species
# of children. 
# * The Replacer determines which members of the previous population 
#   and their children survive to form the population of the next generation.
# * The Selector determines which members of the previous population are selected
#   to serve as parents for the next generation. Parents come as a vector of 
#   Veterans; the presence of one parent multiple times indicates .
# * The Recombiner may either generate a single child from crossover of some set taken from
#   the parents; the IdentityRecombiner simply returns the parents as cloned children.
# * For each Mutator, the children are mutated according to the mutator's parameters.
#   The mutators are applied in the order they are given in the spawner.
# Finally, the newly selected population along with their children are returned as a Species.
function(s::Spawner)(rng::AbstractRNG, sc::SpawnCounter, vets::Species)
    pop = s.replacer(rng, vets)
    parents = s.selector(rng, pop)
    children = s.recombiner(rng, sc, parents)
    for mutator in s.mutators
        children = mutator(rng, sc, children)
    end
    Species(s.spid, s.phenocfg, [vet.indiv for vet in pop], children)
end

# Using the EvoState of the CoevConfig, the spawner will generate a new Species
function(s::Spawner)(evostate::EvoState, allvets::Dict{Symbol, <:Species})
    s(evostate.rng, evostate.counters[s.spid], allvets[s.spid])
end

function Species(rng::AbstractRNG, sc::SpawnCounter, s::Spawner, args...)
    pop = s.icfg(rng, sc, s.npop, args...)
    Species(s.spid, s.phenocfg, pop)
end

function Species(evostate::EvoState, s::Spawner, args...)
    Species(evostate.rng, evostate.counters[s.spid], s, args...)
end

function EvoState(rng::AbstractRNG, spawners::Dict{Symbol, <:Spawner})
    EvoState(rng, map(s -> s.spid, values(spawners)))
end

function EvoState(seed::Union{UInt64, Int}, spawners::Dict{Symbol, <:Spawner})
    EvoState(StableRNG(seed), spawners)
end