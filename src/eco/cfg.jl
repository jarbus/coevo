module Eco
export EvolverCfg
export makevets
export interact, archive!

using ..Common
using ..Reproduction
using ..Jobs
using Random
using JLD2
using StableRNGs

# The EcosystemCfg is a configuration for a single trial of a coevolutionary algorithm.
# It contains the following fields:

struct EcosystemCfg{
    J <: JobConfiguration, 
    O <: Order, 
    S <: Spawner, 
    L <: Logger,
    A <: Archivist
} <: EcosystemConfiguration
    id::String
    trial::Int
    rng::AbstractRNG
    counters::Dict{Symbol, SpawnCounter}
    ecostate::EvoState
    job_cfg::J
    orders::Dict{String, O}
    spawners::Dict{String, S}
    loggers::Dict{String, L}
    archivists::Dict{String, A}
end


function EcosystemCfg(
    id::String = "eco", # Unique identifier for the ecosystem
    trial::Int = 1; # The trial number
    seed::Union{UInt64, Int}, # The seed for the random number generator
    jobcfg::JobConfig = SerialPhenoJobConfig(), # Configuration for dispatching interaction jobs
    orders::Vector{<:Order},
    spawners::Vector{<:Spawner},
)
    orders = Dict(order.oid => order for order in orders)
    spawners = Dict(spawner.spid => spawner for spawner in values(spawners))
    rng = StableRNG(seed)
    evostate = EvoState(rng, collect(keys(spawners)))
    CoevConfig(
        eco, trial, evostate, jobcfg, orders, spawners, loggers, jld2path, arxiv_interval,
        Dict{Int, Dict{Symbol, Species}}(), log_interval,
    )
end


function evolve!(
    start::Int, ngen::Int, coev_cfg::CoevConfig, allsp::Dict{Symbol, <:Species},
)
    eco, trial = coev_cfg.eco, coev_cfg.trial
    println("starting: $eco-$trial")
    for gen in start:ngen
        allsp = coev_cfg(gen, allsp)
        if gen % 10 == 0
            GC.gc()
        end
    end
end


# Default evolutionary loop. Takes in a generation number and a dict of species and 
# produces the next generation of species and filling the JLD2 archive for the trial.
function(c::CoevConfig)(gen::Int, allsp::Dict{Symbol, <:Species})
    # If we have reached a logging interval, log the times taken to perform
    # each step of the coevolutionary GA (archiving previous generation, 
    # performing interactions, an spawning new species)
    if c.log_interval > 0 && gen % c.log_interval == 0
        t = time()
        archive!(gen, c, allsp)
        atime = time() - t
        t = time()
        allvets, outcomes = interact(c, allsp)
        itime = time() - t
        t = time()
        nextsp = Dict(
            spawner.spid => spawner(c.evostate, allvets) for spawner in values(c.spawners)
        )
        stime = time() - t
        println("trial: $(c.trial) gen: $gen, archive: $atime, interact: $itime, spawn: $stime")
        nextsp
    else
        # Otherwise we perform the operations silently
        archive!(gen, c, allsp)
        allvets, outcomes = interact(c, allsp)
        nextsp = Dict(
            spawner.spid => spawner(c.evostate, allvets) for spawner in values(c.spawners)
        )
        nextsp
    end
end

# Generate a dictionary of species from a CoevConfig
# Each species is generated by its respective spawner, with a population of organisms
function(c::CoevConfig)()::Dict{Symbol, <:Species}
    allsp = Dict(spawner.spid => spawner(c.evostate) for spawner in values(c.spawners))
    allsp
end

end