export Spawner, Species
export ScoreOutcome, IdentitySelector, Replacer
export EvoState

"""
    SpeciesCfg(
        id::String = "species",
        n_indiv::Int = 10,
        genocfg::GenotypeConfiguration = GPGenoCfg(),
        phenocfg::PhenotypeConfiguration = DefaultPhenoCfg(),
        replacer::Replacer = IdentityReplacer(),
        selector::Selector = IdentitySelector(),
        recombiner::Recombiner = IdentityRecombiner(),
        mutators::Vector{Mutator} = Mutator[],
    )

    Return a Species object comprising the initial population for a species in the ecosystem.

    # Arguments
    - `id::String`: Unique identifier for the species
    - `n_indiv::Int`: Number of individuals to spawn
    - `genocfg::GenotypeConfiguration`: Configuration for generating genotypes
    - `phenocfg::PhenotypeConfiguration`: Configuration for generating phenotypes from the genotypes
    - `replacer::Replacer`: Pick members of the previous population to keep or replace with children
    - `selector::Selector`: Select members of the previous population to use as parents
    - `recombiner::Recombiner`: Generate children from the selected parents
    - `mutators::Vector{Mutator}`: Mutate each children sequentially ith the given mutators
    - `curr_indiv_id::Int`: The current individual id to use when generating new individuals
    - `curr_gene_id::Int`: The current gene id to use when generating new genes for an individual
"""
@Base.kwdef mutable struct SpeciesCfg{
    G <: GenotypeConfiguration, 
    P <: PhenotypeConfiguration, 
    RP <: Replacer, 
    S <: Selector,
    RC <: Recombiner, 
    M <: Mutator
}
    id::String = "species"
    n_indiv::Int = 10 
    genocfg::G = GPGenoCfg()
    phenocfg::P = DefaultPhenoCfg()
    replacer::RP = IdentityReplacer()
    selector::S = IdentitySelector()
    recombiner::RC = IdentityRecombiner()
    mutators::Vector{M} = Mutator[]
    curr_indiv_id::Int = 1
    curr_gene_id::Int = 1
end


# The initial population for each species is generated by the spawner's IndivConfig
# A Species is created and tagged it the spawner's PhenoCfg and returned
# function(s::Spawner)(rng::AbstractRNG, sc::SpawnCounter)
#     pop = s.icfg(rng, sc, s.npop, s.spargs...)
#     Species(s.spid, s.phenocfg, pop)
# end

function(cfg::SpeciesCfg)(rng::AbstractRNG)
    genos = s.genocfg(rng, sc, s.npop, s.spargs...)
    #genos = [s.genocfg(rng, sc, s.spargs...) for _ in 1:s.npop]
    iids = [iid!(sc) for _ in 1:s.npop]
    pop = Dict(IndivKey(s.spid, iid) => BasicIndiv(IndivKey(s.spid, iid), geno, 0) for (iid, geno) in zip(iids, genos))
    Species(s.spid, s.phenocfg, pop, Dict{IndivKey, Individual}())
end


# This fulfills the core reproduction phase of the evolutionary algorithm
# Given an input of a Species of veterans, the spawner will generate a new Species
# of children. 
# * The Replacer determines which members of the previous population 
#   and their children survive to form the population of the next generation.
# * The Selector determines which members of the previous population are selected
#   to serve as parents for the next generation. Parents come as a vector of 
#   Veterans; the presence of one parent multiple times indicates .
# * The Recombiner may either generate a single child from crossover of some set taken from
#   the parents; the IdentityRecombiner simply returns the parents as cloned children.
# * For each Mutator, the children are mutated according to the mutator's parameters.
#   The mutators are applied in the order they are given in the spawner.
# Finally, the newly selected population along with their children are returned as a Species.
function(s::Spawner)(rng::AbstractRNG, sc::SpawnCounter, vets::Species)
    pop = s.replacer(rng, vets)
    parents = s.selector(rng, pop)
    children = s.recombiner(rng, sc, parents)
    for mutator in s.mutators
        children = mutator(rng, sc, children)
    end
    Species(s.spid, s.phenocfg, [BasicIndiv(vet.ikey, vet.geno, vet.pid) for vet in pop], children)
end

# Using the EvoState of the CoevConfig, the spawner will generate a new Species
function(s::Spawner)(evostate::EvoState, allvets::Dict{Symbol, <:Species})
    s(evostate.rng, evostate.counters[s.spid], allvets[s.spid])
end

function Species(rng::AbstractRNG, sc::SpawnCounter, s::Spawner, args...)
    pop = s.icfg(rng, sc, s.npop, args...)
    Species(s.spid, s.phenocfg, pop)
end

function Species(evostate::EvoState, s::Spawner, args...)
    Species(evostate.rng, evostate.counters[s.spid], s, args...)
end

function EvoState(rng::AbstractRNG, spawners::Dict{Symbol, <:Spawner})
    EvoState(rng, map(s -> s.spid, values(spawners)))
end

function EvoState(seed::Union{UInt64, Int}, spawners::Dict{Symbol, <:Spawner})
    EvoState(StableRNG(seed), spawners)
end

function indiv_id!(cfg::SpeciesCfg)
    id = cfg.curr_indiv_id
    cfg.curr_indiv_id += 1
    id
end

function indiv_ids!(cfg::SpeciesCfg, n::Int)
    [indiv_id!(cfg) for _ in 1:n]
end

function gene_ids!(cfg::SpeciesCfg, n::Int)
    [gene_id!(cfg) for _ in 1:n]
end

function gene_id!(cfg::SpeciesCfg)
    id = cfg.curr_gene_id
    cfg.curr_gene_id += 1
    id
end